#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

// https://zh.wikipedia.org/wiki/%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0
// https://stackoverflow.com/posts/9073675/revisions

#define sign(x) ((x >= 0)? 1 : -1)
#define abs(x) ((x > 0)? (x) : -(x))

#ifdef DEB
#define logf(x) printf(#x ":%.6f ", x)
#define logfn(x) printf(#x ":%.6f\n", x)
#define logd(x) printf(#x ":%d ", x)
#define logdn(x) printf(#x ":%d\n", x)
#define log(fmt, x...) printf("%s %d " x, __func__,__LINE__, ##x) 
#else
#define logf(x)
#define logfn(x)
#define logd(x)
#define logdn(x)
#define log(fmt, x...)
#endif

#define fastsmall (0.05f)
#define fastpi (3.14159265358f)
#define fastpi_2 (1.5707963267948966f)
#define fastpi_4 (0.7853981633974483f)
#define fast2pi (6.283185307179586)

//const static float fastpi2 = 3.14159265358f * 3.14159265358f;

static inline int mod(int a, int b)
{
    return a - ((a/b)*b);
}

/* should be power of 2 */
static inline int mod2(int a, int b)
{
    return a & (b - 1);
}

static inline int fast_fmod2(float x, float m, int q, float *ax)
{
    float _x = x / m;
    int _ix = _x;
    *ax = (_x - _ix) * m;
    return mod2(_ix, q);
}

static inline float max(float x, float y)
{
    return (x > y)? x: y;
}
static inline float min(float x, float y)
{
    return (x < y)? x: y;
}
static inline float absf(float x)
{
    return (x < 0)? -x: x;
}

static float quadInterpolation(
    float a0[2], float a1[2], float a2[2], float f)
{
    float af0x = f - a0[0];
    float af1x = f - a1[0];
    float af2x = f - a2[0];
    float a01x = a0[0] - a1[0];
    float a02x = a0[0] - a2[0];
    float a12x = a1[0] - a2[0];
    float t0 = af1x / a02x;
    float t1 = af2x / a01x;
    float t2 = af0x / a12x;
    return t1 * (a0[1] * t0 - a1[1] * t2) + a2[1] * t2 * t0;
}

float fast_asin2(float x)
{
    static const float lkt[1001] = {
       0.        , 0.001     , 0.002     , 0.003     , 0.00400001,
       0.00500002, 0.00600004, 0.00700006, 0.00800009, 0.00900012,
       0.01000017, 0.01100022, 0.01200029, 0.01300037, 0.01400046,
       0.01500056, 0.01600068, 0.01700082, 0.01800097, 0.01900114,
       0.02000133, 0.02100154, 0.02200178, 0.02300203, 0.0240023 ,
       0.0250026 , 0.02600293, 0.02700328, 0.02800366, 0.02900407,
       0.0300045 , 0.03100497, 0.03200546, 0.03300599, 0.03400655,
       0.03500715, 0.03600778, 0.03700845, 0.03800915, 0.03900989,
       0.04001067, 0.0410115 , 0.04201236, 0.04301326, 0.04401421,
       0.0450152 , 0.04601624, 0.04701732, 0.04801845, 0.04901963,
       0.05002086, 0.05102213, 0.05202346, 0.05302484, 0.05402628,
       0.05502777, 0.05602931, 0.05703091, 0.05803257, 0.05903428,
       0.06003606, 0.06103789, 0.06203979, 0.06304175, 0.06404377,
       0.06504586, 0.06604801, 0.06705023, 0.06805251, 0.06905487,
       0.07005729, 0.07105979, 0.07206235, 0.07306499, 0.0740677 ,
       0.07507049, 0.07607335, 0.07707629, 0.07807931, 0.0790824 ,
       0.08008558, 0.08108884, 0.08209217, 0.08309559, 0.0840991 ,
       0.08510269, 0.08610636, 0.08711013, 0.08811398, 0.08911792,
       0.09012195, 0.09112607, 0.09213028, 0.09313458, 0.09413898,
       0.09514348, 0.09614807, 0.09715276, 0.09815755, 0.09916243,
       0.10016742, 0.10117251, 0.1021777 , 0.103183  , 0.1041884 ,
       0.1051939 , 0.10619951, 0.10720523, 0.10821106, 0.109217  ,
       0.11022305, 0.11122921, 0.11223549, 0.11324188, 0.11424838,
       0.115255  , 0.11626174, 0.11726859, 0.11827557, 0.11928266,
       0.12028988, 0.12129722, 0.12230469, 0.12331228, 0.12431999,
       0.12532783, 0.1263358 , 0.1273439 , 0.12835213, 0.12936049,
       0.13036898, 0.13137761, 0.13238637, 0.13339526, 0.13440429,
       0.13541346, 0.13642277, 0.13743222, 0.13844181, 0.13945154,
       0.14046141, 0.14147143, 0.1424816 , 0.14349191, 0.14450237,
       0.14551297, 0.14652373, 0.14753464, 0.14854569, 0.14955691,
       0.15056827, 0.15157979, 0.15259147, 0.15360331, 0.1546153 ,
       0.15562745, 0.15663977, 0.15765224, 0.15866488, 0.15967768,
       0.16069065, 0.16170379, 0.16271709, 0.16373056, 0.1647442 ,
       0.16575801, 0.16677199, 0.16778615, 0.16880048, 0.16981499,
       0.17082967, 0.17184453, 0.17285957, 0.17387479, 0.17489019,
       0.17590577, 0.17692153, 0.17793748, 0.17895362, 0.17996994,
       0.18098645, 0.18200315, 0.18302004, 0.18403712, 0.18505439,
       0.18607186, 0.18708952, 0.18810738, 0.18912544, 0.19014369,
       0.19116215, 0.1921808 , 0.19319966, 0.19421872, 0.19523798,
       0.19625745, 0.19727713, 0.19829701, 0.1993171 , 0.20033741,
       0.20135792, 0.20237865, 0.20339959, 0.20442075, 0.20544212,
       0.20646371, 0.20748552, 0.20850754, 0.20952979, 0.21055226,
       0.21157496, 0.21259788, 0.21362103, 0.2146444 , 0.215668  ,
       0.21669183, 0.21771589, 0.21874019, 0.21976471, 0.22078947,
       0.22181447, 0.2228397 , 0.22386518, 0.22489089, 0.22591684,
       0.22694304, 0.22796947, 0.22899616, 0.23002308, 0.23105026,
       0.23207768, 0.23310536, 0.23413328, 0.23516146, 0.23618988,
       0.23721857, 0.23824751, 0.2392767 , 0.24030616, 0.24133587,
       0.24236585, 0.24339609, 0.24442659, 0.24545736, 0.24648839,
       0.24751969, 0.24855126, 0.2495831 , 0.25061521, 0.2516476 ,
       0.25268026, 0.25371319, 0.2547464 , 0.25577989, 0.25681365,
       0.2578477 , 0.25888203, 0.25991665, 0.26095155, 0.26198673,
       0.2630222 , 0.26405796, 0.26509401, 0.26613036, 0.26716699,
       0.26820392, 0.26924115, 0.27027867, 0.27131649, 0.27235461,
       0.27339303, 0.27443176, 0.27547078, 0.27651012, 0.27754975,
       0.2785897 , 0.27962996, 0.28067053, 0.28171141, 0.2827526 ,
       0.28379411, 0.28483593, 0.28587808, 0.28692054, 0.28796332,
       0.28900643, 0.29004986, 0.29109361, 0.29213769, 0.2931821 ,
       0.29422684, 0.29527191, 0.29631731, 0.29736304, 0.29840911,
       0.29945552, 0.30050226, 0.30154935, 0.30259677, 0.30364454,
       0.30469265, 0.30574111, 0.30678992, 0.30783907, 0.30888857,
       0.30993843, 0.31098864, 0.3120392 , 0.31309012, 0.3141414 ,
       0.31519303, 0.31624503, 0.31729739, 0.31835011, 0.3194032 ,
       0.32045665, 0.32151048, 0.32256467, 0.32361924, 0.32467417,
       0.32572949, 0.32678518, 0.32784124, 0.32889769, 0.32995452,
       0.33101173, 0.33206932, 0.3331273 , 0.33418567, 0.33524443,
       0.33630358, 0.33736312, 0.33842305, 0.33948338, 0.3405441 ,
       0.34160523, 0.34266676, 0.34372868, 0.34479102, 0.34585375,
       0.3469169 , 0.34798045, 0.34904441, 0.35010879, 0.35117358,
       0.35223879, 0.35330441, 0.35437045, 0.35543691, 0.3565038 ,
       0.3575711 , 0.35863884, 0.359707  , 0.36077559, 0.36184461,
       0.36291407, 0.36398396, 0.36505428, 0.36612505, 0.36719625,
       0.36826789, 0.36933998, 0.37041251, 0.37148549, 0.37255892,
       0.3736328 , 0.37470713, 0.37578192, 0.37685716, 0.37793286,
       0.37900902, 0.38008564, 0.38116272, 0.38224027, 0.38331829,
       0.38439677, 0.38547573, 0.38655516, 0.38763506, 0.38871544,
       0.3897963 , 0.39087763, 0.39195945, 0.39304176, 0.39412455,
       0.39520782, 0.39629159, 0.39737585, 0.3984606 , 0.39954585,
       0.40063159, 0.40171784, 0.40280458, 0.40389183, 0.40497959,
       0.40606785, 0.40715662, 0.40824591, 0.4093357 , 0.41042602,
       0.41151685, 0.4126082 , 0.41370007, 0.41479246, 0.41588538,
       0.41697883, 0.41807281, 0.41916732, 0.42026236, 0.42135794,
       0.42245406, 0.42355072, 0.42464792, 0.42574567, 0.42684396,
       0.4279428 , 0.4290422 , 0.43014214, 0.43124264, 0.4323437 ,
       0.43344532, 0.4345475 , 0.43565025, 0.43675356, 0.43785744,
       0.43896189, 0.44006691, 0.44117251, 0.44227868, 0.44338544,
       0.44449278, 0.4456007 , 0.44670921, 0.44781831, 0.44892799,
       0.45003828, 0.45114916, 0.45226063, 0.45337271, 0.45448539,
       0.45559867, 0.45671257, 0.45782707, 0.45894218, 0.46005791,
       0.46117426, 0.46229123, 0.46340882, 0.46452703, 0.46564587,
       0.46676534, 0.46788544, 0.46900618, 0.47012755, 0.47124956,
       0.47237221, 0.47349551, 0.47461946, 0.47574405, 0.4768693 ,
       0.4779952 , 0.47912176, 0.48024897, 0.48137685, 0.4825054 ,
       0.48363461, 0.48476449, 0.48589505, 0.48702628, 0.48815819,
       0.48929078, 0.49042405, 0.49155801, 0.49269266, 0.493828  ,
       0.49496403, 0.49610076, 0.49723819, 0.49837633, 0.49951517,
       0.50065471, 0.50179497, 0.50293594, 0.50407763, 0.50522004,
       0.50636317, 0.50750702, 0.50865161, 0.50979692, 0.51094297,
       0.51208975, 0.51323728, 0.51438554, 0.51553456, 0.51668432,
       0.51783483, 0.5189861 , 0.52013812, 0.52129091, 0.52244446,
       0.52359878, 0.52475386, 0.52590972, 0.52706636, 0.52822377,
       0.52938197, 0.53054095, 0.53170072, 0.53286128, 0.53402264,
       0.53518479, 0.53634775, 0.53751151, 0.53867608, 0.53984146,
       0.54100765, 0.54217466, 0.54334249, 0.54451115, 0.54568064,
       0.54685095, 0.5480221 , 0.54919409, 0.55036692, 0.55154059,
       0.55271511, 0.55389049, 0.55506671, 0.5562438 , 0.55742175,
       0.55860057, 0.55978025, 0.56096081, 0.56214224, 0.56332455,
       0.56450775, 0.56569183, 0.5668768 , 0.56806267, 0.56924944,
       0.57043711, 0.57162568, 0.57281517, 0.57400557, 0.57519688,
       0.57638911, 0.57758227, 0.57877636, 0.57997138, 0.58116734,
       0.58236424, 0.58356208, 0.58476087, 0.58596061, 0.58716131,
       0.58836297, 0.58956559, 0.59076918, 0.59197374, 0.59317928,
       0.5943858 , 0.5955933 , 0.5968018 , 0.59801128, 0.59922177,
       0.60043325, 0.60164574, 0.60285925, 0.60407376, 0.6052893 ,
       0.60650586, 0.60772344, 0.60894206, 0.61016171, 0.61138241,
       0.61260415, 0.61382694, 0.61505078, 0.61627569, 0.61750165,
       0.61872869, 0.6199568 , 0.62118599, 0.62241625, 0.62364761,
       0.62488006, 0.6261136 , 0.62734825, 0.628584  , 0.62982086,
       0.63105884, 0.63229794, 0.63353817, 0.63477952, 0.63602202,
       0.63726565, 0.63851043, 0.63975636, 0.64100345, 0.64225169,
       0.64350111, 0.6447517 , 0.64600346, 0.64725641, 0.64851054,
       0.64976587, 0.65102239, 0.65228012, 0.65353906, 0.65479922,
       0.65606059, 0.65732319, 0.65858702, 0.65985209, 0.66111841,
       0.66238597, 0.66365478, 0.66492486, 0.6661962 , 0.66746881,
       0.6687427 , 0.67001788, 0.67129434, 0.6725721 , 0.67385116,
       0.67513153, 0.67641322, 0.67769622, 0.67898055, 0.68026621,
       0.68155321, 0.68284156, 0.68413125, 0.68542231, 0.68671473,
       0.68800852, 0.68930369, 0.69060024, 0.69189818, 0.69319752,
       0.69449827, 0.69580042, 0.69710399, 0.69840899, 0.69971542,
       0.70102328, 0.70233259, 0.70364336, 0.70495558, 0.70626927,
       0.70758444, 0.70890108, 0.71021922, 0.71153884, 0.71285998,
       0.71418262, 0.71550678, 0.71683247, 0.71815969, 0.71948845,
       0.72081876, 0.72215063, 0.72348406, 0.72481906, 0.72615565,
       0.72749382, 0.72883359, 0.73017496, 0.73151794, 0.73286255,
       0.73420879, 0.73555666, 0.73690618, 0.73825736, 0.73961019,
       0.7409647 , 0.74232089, 0.74367877, 0.74503835, 0.74639963,
       0.74776263, 0.74912736, 0.75049382, 0.75186202, 0.75323198,
       0.7546037 , 0.75597719, 0.75735246, 0.75872952, 0.76010838,
       0.76148905, 0.76287154, 0.76425586, 0.76564202, 0.76703003,
       0.7684199 , 0.76981164, 0.77120526, 0.77260077, 0.77399818,
       0.7753975 , 0.77679874, 0.77820191, 0.77960703, 0.78101411,
       0.78242315, 0.78383416, 0.78524716, 0.78666216, 0.78807918,
       0.78949821, 0.79091928, 0.79234239, 0.79376755, 0.79519479,
       0.79662411, 0.79805552, 0.79948903, 0.80092466, 0.80236242,
       0.80380232, 0.80524437, 0.8066886 , 0.808135  , 0.80958359,
       0.81103439, 0.81248741, 0.81394267, 0.81540016, 0.81685992,
       0.81832195, 0.81978627, 0.82125288, 0.82272182, 0.82419308,
       0.82566668, 0.82714264, 0.82862098, 0.8301017 , 0.83158482,
       0.83307036, 0.83455833, 0.83604875, 0.83754163, 0.83903699,
       0.84053484, 0.8420352 , 0.84353809, 0.84504352, 0.84655151,
       0.84806208, 0.84957524, 0.851091  , 0.85260939, 0.85413043,
       0.85565412, 0.85718049, 0.85870956, 0.86024134, 0.86177585,
       0.86331312, 0.86485315, 0.86639596, 0.86794159, 0.86949004,
       0.87104133, 0.87259549, 0.87415253, 0.87571247, 0.87727534,
       0.87884115, 0.88040993, 0.88198169, 0.88355646, 0.88513425,
       0.88671509, 0.88829901, 0.88988602, 0.89147614, 0.8930694 ,
       0.89466582, 0.89626542, 0.89786823, 0.89947427, 0.90108356,
       0.90269613, 0.904312  , 0.9059312 , 0.90755374, 0.90917967,
       0.910809  , 0.91244175, 0.91407796, 0.91571765, 0.91736085,
       0.91900758, 0.92065787, 0.92231175, 0.92396925, 0.9256304 ,
       0.92729522, 0.92896374, 0.930636  , 0.93231202, 0.93399183,
       0.93567547, 0.93736296, 0.93905434, 0.94074964, 0.94244888,
       0.94415212, 0.94585936, 0.94757066, 0.94928604, 0.95100554,
       0.95272919, 0.95445704, 0.9561891 , 0.95792543, 0.95966606,
       0.96141102, 0.96316035, 0.9649141 , 0.9666723 , 0.96843498,
       0.9702022 , 0.97197399, 0.97375039, 0.97553144, 0.97731719,
       0.97910768, 0.98090296, 0.98270306, 0.98450803, 0.98631793,
       0.98813279, 0.98995266, 0.99177758, 0.99360762, 0.99544282,
       0.99728322, 0.99912888, 1.00097986, 1.00283619, 1.00469794,
       1.00656517, 1.00843791, 1.01031624, 1.01220021, 1.01408988,
       1.01598529, 1.01788653, 1.01979364, 1.02170668, 1.02362573,
       1.02555084, 1.02748208, 1.02941951, 1.03136321, 1.03331324,
       1.03526967, 1.03723257, 1.03920202, 1.04117809, 1.04316084,
       1.04515037, 1.04714675, 1.04915005, 1.05116035, 1.05317775,
       1.05520232, 1.05723415, 1.05927332, 1.06131993, 1.06337407,
       1.06543582, 1.06750528, 1.06958255, 1.07166773, 1.07376091,
       1.0758622 , 1.0779717 , 1.08008953, 1.08221578, 1.08435057,
       1.08649401, 1.08864622, 1.09080732, 1.09297743, 1.09515667,
       1.09734517, 1.09954306, 1.10175047, 1.10396754, 1.1061944 ,
       1.1084312 , 1.11067809, 1.11293521, 1.11520272, 1.11748076,
       1.11976951, 1.12206913, 1.12437979, 1.12670165, 1.1290349 ,
       1.13137972, 1.1337363 , 1.13610482, 1.13848548, 1.14087849,
       1.14328406, 1.1457024 , 1.14813372, 1.15057826, 1.15303625,
       1.15550792, 1.15799353, 1.16049332, 1.16300756, 1.16553653,
       1.16808049, 1.17063973, 1.17321455, 1.17580526, 1.17841216,
       1.18103559, 1.18367589, 1.1863334 , 1.18900847, 1.19170149,
       1.19441284, 1.19714292, 1.19989215, 1.20266095, 1.20544976,
       1.20825906, 1.21108933, 1.21394105, 1.21681476, 1.21971099,
       1.22263031, 1.22557329, 1.22854056, 1.23153276, 1.23455054,
       1.2375946 , 1.24066568, 1.24376453, 1.24689195, 1.25004878,
       1.2532359 , 1.25645422, 1.25970473, 1.26298843, 1.2663064 ,
       1.26965978, 1.27304977, 1.27647762, 1.27994469, 1.28345238,
       1.28700222, 1.29059579, 1.29423481, 1.2979211 , 1.30165659,
       1.30544338, 1.30928368, 1.31317989, 1.31713459, 1.32115056,
       1.32523081, 1.32937859, 1.33359746, 1.33789127, 1.34226425,
       1.34672104, 1.35126674, 1.355907  , 1.36064808, 1.36549696,
       1.37046148, 1.37555046, 1.3807739 , 1.38614321, 1.39167151,
       1.39737401, 1.40326848, 1.40937598, 1.41572165, 1.42233606,
       1.42925685, 1.43653142, 1.44422074, 1.4524056 , 1.46119697,
       1.47075461, 1.48132377, 1.49331728, 1.50754023, 1.52607124,
       fastpi_2
    };
    float signa = sign(x);
    float ax = abs(x);
    int idx = ax * 1000;
    if (idx == 0) return 0.0;
    else if (idx == 1000) return signa * fastpi_2;
    float fidx = (float)idx / 1000;
    float a0[] = {fidx-0.001, lkt[idx-1]};
    float a1[] = {fidx, lkt[idx]};
    float a2[] = {fidx+0.001, lkt[idx+1]};
    float y =  signa * quadInterpolation(a0, a1, a2, ax);
    //printf("[%s %d] idx:%d ax:%.4f a0[%.4f,%.4f] a0[%.4f,%.4f], a0[%.4f,%.4f] => %.4f\n", __func__,__LINE__,idx, ax,
    //    a0[0], a0[1], a1[0], a1[1], a2[0], a2[1], y);
    return y;
}

#define cubic(ax, b, a0, a1, a2) ((b) + (ax) * ((a0) + (ax) * ((a1) + (ax) * (a2)))) 
#define quad(ax, b, a0, a1) ((b) + (ax) * ((a0) + (ax) * (a1)))

#define cubicArr(ax, a) ((a[0]) + (ax) * ((a[1]) + (ax) * ((a[2]) + (ax) * (a[3])))) 
#define quadArr(ax, a) ((a[0]) + (ax) * ((a[1]) + (ax) * (a[2])))

static inline float lerp(float a, float b, float x)
{
    return a * x + b;   
}

float fast_atan(float x)
{
    const static float a0[4] = {
        -0.0037002278175466974,
        1.04710252,
        -0.18627361,
        -0.07857707
    };
    const static float a1[4] = { 
        -0.03835873083805175,
        1.22213379,
        -0.47333034,
        0.0749329
    };
    const static float a2[4] = { 
        0.23748654401677938,
        0.74395186,
        -0.19253416,
        0.01897149
    };
    const static float a3[4] = {
        0.6655143527424704,
        0.31987618,
        -0.05084753,
        0.00303765
    };
    const static float a4[4] = {
        1.029536240433053,
        0.10961277,
        -0.00974906,
        0.00032041
    };

    const static float atan_high_thr     = 10.0f;
    const static float atan_higl_thr     = 5.0f;
    const static float atan_midh_thr     = fastpi;
    const static float atan_mid_thr      = fastpi_2;
    const static float atan_mids_thr     = fastpi_4;
    const static float atan_smal_thr     = 0.1;

    int signX = sign(x);
    float ax = abs(x);

    // https://math.stackexchange.com/questions/982838/asymptotic-approximation-of-the-arctangent/982859
    if (ax > atan_high_thr)       return (signX*(fastpi_2) - 1/x);
    // for small x
    else if (ax < atan_smal_thr)  return x;
    // by regression
    else if (ax < atan_mids_thr)  return signX * cubicArr(ax, a0);
    // by regression
    else if (ax < atan_mid_thr)   return signX * cubicArr(ax, a1);
    // by regression
    else if (ax < atan_midh_thr)  return signX * cubicArr(ax, a2);
    // by regression
    else if (ax < atan_higl_thr)  return signX * cubicArr(ax, a3);
    else                          return signX * cubicArr(ax, a4);
} 

float fast_cos_quad2(float x)
{
    const static float c0=0.9994880721226505;
    const static float c1=-0.49574695;
    const static float c2=0.03677138;
    float x2 = x * x;
    return quad(x2, c0, c1, c2);
    //return 1 + x2 * (-0.5 + 0.041666666666666664 * x2);
}

float fast_cos(float x)
{
    float ax = abs(x);
    //if (ax < fastsmall) return x;
    int quad = fast_fmod2(ax, fastpi_2, 4, &ax);

    if      (quad == 0) return fast_cos_quad2(ax);
    else if (quad == 1) return -fast_cos_quad2(fastpi_2 - ax);
    else if (quad == 2) return -fast_cos_quad2(ax);
    else if (quad == 3) return fast_cos_quad2(fastpi_2 - ax);
    else assert(0);
}

float fast_sin(float x)
{
    log("%.6f\n", x);
    return fast_cos(fastpi_2 - x);
}

float fast_tan(float x)
{
    /* https://mae.ufl.edu/~uhk/ACCURATE-TANGENT.pdf */
    const static float t0[] = { // 0.05 to 0.8
        -0.005306908868911164,
        1.07958615,
        -0.31961611,
        0.72791356
    };
    const static float t1[] = { // 0.8 to 1.2
        -6.798523672037293,
        24.20035856,
        -26.75328616,
        10.9062448
    };
    const static float t2[] = { // 1.2 to 1.37
        -288.476741666932,
        715.84338056,
        -593.63206871,
        166.00749918
    };
    const static float t3[] = { // 1.37 to 1.45
        -4043.7026279735396,
        8896.89927632,
        -6536.19587117,
        1605.2422637
    };
    const static float t4[] = { // 1.45 to 1.472
        1513.2746348922383,
        -2142.93149953,
        762.05357123
    };
    const static float t5[] = { // 1.472 to 1.571
       8.23809275e+00, 8.32297410e+00, 8.40959713e+00, 8.49801630e+00,
       8.58828831e+00, 8.68047230e+00, 8.77462995e+00, 8.87082562e+00,
       8.96912650e+00, 9.06960275e+00, 9.17232772e+00, 9.27737805e+00,
       9.38483395e+00, 9.49477931e+00, 9.60730201e+00, 9.72249410e+00,
       9.84045207e+00, 9.96127709e+00, 1.00850754e+01, 1.02119584e+01,
       1.03420433e+01, 1.04754533e+01, 1.06123178e+01, 1.07527733e+01,
       1.08969634e+01, 1.10450395e+01, 1.11971613e+01, 1.13534974e+01,
       1.15142258e+01, 1.16795348e+01, 1.18496236e+01, 1.20247029e+01,
       1.22049964e+01, 1.23907409e+01, 1.25821881e+01, 1.27796052e+01,
       1.29832767e+01, 1.31935050e+01, 1.34106127e+01, 1.36349437e+01,
       1.38668654e+01, 1.41067703e+01, 1.43550786e+01, 1.46122405e+01,
       1.48787389e+01, 1.51550926e+01, 1.54418593e+01, 1.57396399e+01,
       1.60490821e+01, 1.63708858e+01, 1.67058076e+01, 1.70546676e+01,
       1.74183553e+01, 1.77978378e+01, 1.81941682e+01, 1.86084950e+01,
       1.90420739e+01, 1.94962800e+01, 1.99726227e+01, 2.04727622e+01,
       2.09985289e+01, 2.15519462e+01, 2.21352559e+01, 2.27509490e+01,
       2.34018014e+01, 2.40909153e+01, 2.48217690e+01, 2.55982756e+01,
       2.64248532e+01, 2.73065087e+01, 2.82489401e+01, 2.92586589e+01,
       3.03431416e+01, 3.15110147e+01, 3.27722851e+01, 3.41386275e+01,
       3.56237468e+01, 3.72438401e+01, 3.90181892e+01, 4.09699325e+01,
       4.31270796e+01, 4.55238646e+01, 4.82025764e+01, 5.12160763e+01,
       5.46313220e+01, 5.85344018e+01, 6.30378929e+01, 6.82918980e+01,
       7.45011028e+01, 8.19520672e+01, 9.10587111e+01, 1.02441914e+02,
       1.17077345e+02, 1.36591117e+02, 1.63910235e+02, 2.04888709e+02,
       2.73185895e+02, 4.09779859e+02, 8.19560938e+02, 1.63312394e+16
   };
    const static float tan0_th = 0.8;
    const static float tan1_th = 1.2;
    const static float tan2_th = 1.37;
    const static float tan3_th = 1.45;
    const static float tan4_th = 1.472;

    float _x;
    int _ix, _quad, x2;

    int signX = sign(x);
    float ax = abs(x);

    if (ax < fastsmall)
        return x;
    if (ax > fastpi_2) {
        _quad = fast_fmod2(ax, fastpi_2, 2, &ax);
        if (signX >= 0) { // > 0
            if (_quad == 1) {
                ax = fastpi_2 - ax;
                signX = -1;
            } else signX = 1;
        } else {  // < 0
            if (_quad == 0) {}
            else {
                ax = fastpi_2 - ax;
                signX = 1;
            }
                        printf("MOD>> %.4f => %.4f Q[%d] => %s%.4f\n",
                x,ax,_quad,signX>=0?"+":"-",ax);
        }
        if (ax < fastsmall) {
            return signX * ax;
        }
    }
    if (ax < tan0_th)
        return signX * cubicArr(ax, t0);
    else if (ax < tan1_th)
        return signX * cubicArr(ax, t1);
    else if (ax < tan2_th)
        return signX * cubicArr(ax, t2);
    else if (ax < tan3_th)
        return signX * cubicArr(ax, t3);
    else if (ax < tan4_th)
        return signX * quadArr(ax, t4);
    else {
        // 1.471 to 1.571
        float ax_up = ax * 1000;
        int iax_up = ax_up;
        int idx = iax_up - 1472;
        float r = ax_up - iax_up;
        //printf(">>>%.3f=>[%.3f]Q[%d] %.4f %.4f rate:%.4f => %.4f\n",
        //    x, ax, _quad, t5[idx], t5[idx+1], r, signX * lerp(t5[idx], t5[idx+1], r));
        return signX * lerp(t5[idx], t5[idx+1], r);
    }
}


float fast_asin(float x)
{
  float negate = x < 0;
  float ax = abs(x);
  float ret = -0.0187293;
  ret *= ax;
  ret += 0.0742610;
  ret *= ax;
  ret -= 0.2121144;
  ret *= ax;
  ret += 1.5707288;
  ret = fastpi * 0.5 - sqrt(1.0 - ax) * ret;
  return ret - 2 * negate * ret;
}

//https://stackoverflow.com/questions/3380628/fast-arc-cos-algorithm
float fast_acos(float x)
{
  #if 0
  float negate = x < 0;
  float ax = abs(x);
  float ret = -0.0187293;
  ret = ret * ax;
  ret = ret + 0.0742610;
  ret = ret * ax;
  ret = ret - 0.2121144;
  ret = ret * ax;
  ret = ret + 1.5707288;
  ret = ret * sqrt(1.0-ax);
  ret = ret - 2 * negate * ret;
  return negate * 3.14159265358979 + ret;
  
    static const float C  = 0.10501094f;
    float r, s, t, u;
    t = (x < 0) ? (-x) : x;  // handle negative arguments
    u = 1.0f - t;
    s = sqrtf (u + u);
    r = C * u * s + s;  // or fmaf (C * u, s, s) if FMA support in hardware
    if (x < 0) r = fastpi - r;  // handle negative arguments
    return r;
  #endif
  return fastpi_2 - fast_asin2(x);
}



#define MATH_OPS(x) (double (*)(double))(x)
#define OPS_NUM (6)
int app(int argc, char **argv)
{
    float b = atof(argv[2]);
    int range = atoi(argv[3]);
    double (*math_ops[OPS_NUM])(double) = { MATH_OPS(atan), MATH_OPS(sin), MATH_OPS(cos), MATH_OPS(tan), MATH_OPS(acos), MATH_OPS(asin)};
    float (*fast_math[OPS_NUM])(float) = {fast_atan, fast_sin, fast_cos, fast_tan, fast_acos, fast_asin2};
    const char *metstr[] = {"atan", "sin", "cos", "tan", "acos", "asin"};
    unsigned int met = atoi(argv[4]);
    assert(met < OPS_NUM+1);

    float a = 0.0;
    if (strcmp(argv[1], "-0")==0) {
        for (int i = 0; i < range; i++) {
            a = math_ops[met](b);
        }
    } else {
        for (int i = 0; i < range; i++) {
            a = fast_math[met](b);
        }
    }
    printf("selected %s input:%.4f\n", metstr[met], b);
    printf("retval(%.4f)= %.5f\n\n", b, a);

    printf("atan(%.4f) = %.5f\n", b, atan(b));
    printf("sin(%.4f) = %.5f\n", b, sin(b));
    printf("cos(%.4f) = %.5f\n", b, cos(b));
    printf("tan(%.4f) = %.5f\n", b, tan(b));
    printf("acos(%.4f) = %.5f\n", b, acos(b));
    printf("asin(%.4f) = %.5f\n", b, asin(b));
    printf("fast_atan(%.4f) = %.5f\n", b, fast_atan(b));
    printf("fast_sin(%.4f) = %.5f\n", b, fast_sin(b));
    printf("fast_cos(%.4f) = %.5f\n", b, fast_cos(b));
    printf("fast_tan(%.4f) = %.5f\n", b, fast_tan(b));
    printf("fast_acos(%.4f) = %.5f\n", b, fast_acos(b));
    printf("fast_asin(%.4f) = %.5f\n", b, fast_asin(b));
    return 0;
}

int ut_test(int argc, char **argv)
{
    float b = atof(argv[2]);
    int range = atoi(argv[3]);
    double (*math_ops[OPS_NUM])(double) = { MATH_OPS(atan), MATH_OPS(sin), MATH_OPS(cos), MATH_OPS(tan), MATH_OPS(acos), MATH_OPS(asin)};
    float (*fast_math[OPS_NUM])(float) = {fast_atan, fast_sin, fast_cos, fast_tan, fast_acos, fast_asin2};
    const char *metstr[] = {"atan", " sin", " cos", " tan", "acos", "asin"};
    //unsigned int met = atoi(argv[4]);
    //assert(met < 5);

    float _max[OPS_NUM] = { 0 };
    float _min[OPS_NUM] = { 0 };
    float _max_val[OPS_NUM] = { 0 };
    float _min_val[OPS_NUM] = { 0 };
    float _sum[OPS_NUM] = { 0 };
    float _mean[OPS_NUM] = { 0 };
    float *_diff = (float *)malloc(sizeof(float)*range*OPS_NUM);
    float inc = b/range;
    float in = -b/2;
    for (int i = 0; i < range; i++) {
        for (int j = 0; j < OPS_NUM; j++) {
            float val0 = math_ops[j](in);
            float val1 = fast_math[j](in);
            float diff = absf(val0-val1);
            _diff[i*OPS_NUM + j] = diff;
            if (diff > _max[j]) {
                _max[j] = diff;
                _max_val[j] = in;
            }
            if (diff < _min[j]) {
                _min[j] = diff;
                _min_val[j] = in;
            }
            _sum[j] += diff;
        }
        in += inc;
    }
    for (int i = 0; i < OPS_NUM; i++) {
        _mean[i] = _sum[i] / range;
    }
    printf("========= unit-test acc summary ========\n\n");
    printf(" test range [%.6f --- %.6f]\n", -b/2 , b/2 );
    printf("                 math vs fast_tri\n");
    for (int i = 0; i < OPS_NUM; i++) {
       printf("%8s:: max:%.6f(%.4f) min:%.6f(%.4f) mean:%.6f\n",
        metstr[i], _max[i], _max_val[i], _min[i], _min_val[i], _mean[i]);
    }
    FILE *fp = fopen("diff.bin", "wb");
    fwrite(_diff, 1, sizeof(float)*range*OPS_NUM, fp);
    fclose(fp);
    free(_diff);
    return 0;
}

void help()
{
    printf(
        "===============\n"
        "\targc:5 => [-0(math)/else(fast_math)] [input float] [iters] [fast_ops_method]\n"
        "\targc:4 => [dummy] [range * -pi/2 to pi/2] [arr size]\n"
        );
}
int main(int argc, char **argv)
{
 
    double (*math)(double) = atan;    
    if (argc == 5)
        app(argc, argv);
    else if (argc == 4)
        ut_test(argc, argv);
    else
        help();
    return 0;
}

/* time ./app {-0} 7.2 100000000 {0}
| | math | fast math |
| atan | 2.501 |  0.526 |
| sin | 5.367 | 1.944 |
| cos | 4.626 | 1.700 |
| tan | | |
*/